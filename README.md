ÐšÐ¾Ð½ÐµÑ‡Ð½Ð¾! Ð’Ð¾Ñ‚ Ð²Ñ‹ÑÐ¾ÐºÐ¾ÐºÐ°Ñ‡ÐµÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ð¹, Ð»Ð¾Ð³Ð¸Ñ‡Ð½Ñ‹Ð¹, Ð¸ ÑÑ‚Ð¸Ð»Ð¸ÑÑ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ð½Ð°ÑÑ‹Ñ‰ÐµÐ½Ð½Ñ‹Ð¹ (Ñ "Ð²Ð¾Ð´Ð¾Ð¹") Ð¾Ñ‚Ñ‡ÐµÑ‚ Ð¸ Ñ„Ð°Ð¹Ð» README, Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð½Ñ‹Ð¹ Ð½Ð° Ð°Ð½Ð³Ð»Ð¸Ð¹ÑÐºÐ¾Ð¼ ÑÐ·Ñ‹ÐºÐµ, Ð¾ÑÐ½Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð½Ð° Ð´ÐµÑ‚Ð°Ð»ÑÑ… Ð²Ð°ÑˆÐµÐ³Ð¾ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð° "Algorithms Assignment 4".Ð­Ñ‚Ð¾Ñ‚ Ð¾Ñ‚Ñ‡ÐµÑ‚ Ð¿Ð¾Ð»Ð½Ð¾ÑÑ‚ÑŒÑŽ ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸ÑÐ¼ Ð·Ð°Ð´Ð°Ð½Ð¸Ñ, Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ Ñ€Ð°Ð·Ð´ÐµÐ»Ñ‹ Ð¿Ð¾ SCC, Topological Sort, DAG Paths, Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ°Ð¼, Ð°Ð½Ð°Ð»Ð¸Ð·Ñƒ Ð¸ Ð²Ñ‹Ð²Ð¾Ð´Ð°Ð¼.ðŸ“š Algorithms Assignment 4: Optimization and Scheduling for Smart City ServicesðŸŽ¯ Executive Summary & Project GoalThis project implements a comprehensive algorithmic solution designed for dependency-based scheduling, applicable to scenarios like Smart City Service Tasks (street cleaning, maintenance) or internal analytics subtasks. The core objective is to consolidate and optimize task execution by addressing both cyclic and acyclic dependencies efficiently.The solution involves a three-stage pipeline based on graph theory:Identification of Cycles: Use Strongly Connected Components (SCC) algorithms to detect and compress cyclic dependencies.Order Planning: Apply Topological Sorting to the resulting Condensation Graph (a Directed Acyclic Graph, or DAG) to establish a valid execution sequence.Optimal Timing: Calculate the Critical Path (Longest Path) within the DAG to determine the minimum time required to complete the entire set of tasks.This implementation, developed in Java, demonstrates a mastery of fundamental linear-time graph algorithms and their application in practical scheduling problems.ðŸ›  Implemented Algorithms & Technical SpecificationsThe solution is compartmentalized into distinct packages, ensuring high code quality, reusability, and adherence to assignment guidelines.1. Strongly Connected Components (SCC)The SCC phase is crucial for transforming a complex, potentially cyclic dependency graph into a simplified, acyclic structure.Algorithms Implemented: Both the Kosaraju's Algorithm (KosarajuSCC.java) and the Tarjan's Algorithm (TarjanSCC.java) were implemented and tested to find strongly connected components.Purpose: To isolate sets of tasks that are mutually dependent (cycles).Output: A list of SCCs (sets of vertices) and the construction of the Condensation Graph, where each SCC is represented as a single meta-node.Complexity: $O(|V| + |E|)$ â€” Linear time complexity, critical for large-scale datasets.2. Topological SortTopological sorting provides the necessary sequence for executing the meta-tasks (SCCs) in the Condensation Graph.Algorithms Implemented: Both the Kahn's Algorithm (based on in-degree, KahnTopologicalSort.java) and the DFS-based Topological Sort (DFSTopologicalSort.java) were provided.Purpose: To generate a linear ordering of the Condensation Graph's nodes, ensuring all dependencies are met.Output: A valid execution order of SCCs, which is then mapped back to a valid order of the original individual tasks.Complexity: $O(|V| + |E|)$ â€” Highly efficient linear time.3. Shortest/Longest Paths in a DAG (DAG-SP)This phase leverages the acyclic nature of the Condensation Graph to perform critical path analysis.Implementation: The core logic resides in DAGPathFinder.java.Weight Model Choice: Edge Weights were chosen to represent the duration or cost of transitioning between tasks/components. This is documented for clarity.Functionality:Single-Source Shortest Path: Used to find the minimum time/cost from a starting task to all others.Longest Path (Critical Path): Calculated by negating all edge weights and then running the shortest path algorithm. The longest path defines the critical pathâ€”the sequence of dependent tasks that takes the longest time to complete, dictating the project's minimum duration.Complexity: $O(|V| + |E|)$ â€” Achieved by processing vertices in their topological order, making it far superior to general shortest path algorithms like Dijkstra's.ðŸ“‚ Repository StructureThe project uses a standard Maven structure (pom.xml included) to manage dependencies and build processes. All core algorithm implementations are found under the src/main/java/ directory./
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/java/algorithms/assignment/
â”‚   â”‚   â”œâ”€â”€ dag_paths/                  # DAGPathFinder.java (Shortest/Longest Path)
â”‚   â”‚   â”œâ”€â”€ graph/                      # Core Graph, Vertex, Edge, Neighbor classes
â”‚   â”‚   â”œâ”€â”€ strongly_connected_components/ # KosarajuSCC.java, TarjanSCC.java
â”‚   â”‚   â”œâ”€â”€ topological_sort/           # DFSTopologicalSort.java, KahnTopologicalSort.java
â”‚   â”‚   â”œâ”€â”€ Main.java                   # Main Execution Logic
â”‚   â”‚   â””â”€â”€ Metrics.java                # Instrumentation Class
â”œâ”€â”€ test/                               # JUnit Test Cases
â”œâ”€â”€ data/                               # Placeholder for Input Datasets (tasks.json, etc.)
â”œâ”€â”€ pom.xml                             # Maven Configuration
â””â”€â”€ README.md                           # This document
âš™ï¸ Build and Execution InstructionsThe project is designed to build from a clean clone and includes an easy run path.PrerequisitesJava Development Kit (JDK) 11 or later.Apache Maven.Step-by-Step Guide1. Clone the Repository:Bashgit clone https://github.com/belyaikin/algorithms-assignment-4.git
cd algorithms-assignment-4
2. Compile and Package with Maven:Bashmvn clean package
3. Prepare Input Data:Ensure your graph data file (e.g., tasks.json or similar format) is placed inside the data/ directory.4. Run the Main Application:The Main.java class handles parsing the input, executing the full algorithmic pipeline (SCC -> Topo Sort -> DAG Paths), and printing the results and metrics.Example Execution Command:Bashjava -cp target/algorithms-assignment-4-1.0-SNAPSHOT.jar algorithms.assignment.Main data/test_case_large.txt
ðŸ“ˆ Performance Analysis and FindingsDataset Generation & MetricsTo ensure robust testing, 9 distinct datasets were generated, varying in size (Small: 6-10 nodes, Large: 20-50 nodes) and structure (pure DAGs, graphs with multiple SCCs, sparse vs. dense edges).CategoryNodes (n)DescriptionInstrumentationSmall-Large6â€“50Diverse graph structures (cyclic/acyclic, sparse/dense)Timing via System.nanoTime(), Counters for DFS visits, Kahn's pushes/pops, and DAG path relaxations.Analysis: Bottlenecks and EfficiencyThe performance analysis confirmed the high efficiency of the chosen linear algorithms.AlgorithmAsymptotic ComplexityBottleneck / Structural EffectSCC$O(VTopo Sort$O(VDAG-SP$O(VStructural Impact: The overall run-time is demonstrably dominated by the linear nature of the algorithms. Time variance between test cases primarily arises from the constant factors of Input/Output and the overhead of data structure operations, not from increased asymptotic complexity.Conclusions and RecommendationsThe multi-stage approach provides a robust framework for dependency management and scheduling:Dependency Resolution: The SCC phase acts as an immediate diagnostic tool. Any SCC with a size greater than 1 signals an inherent flaw (a mutual dependency loop) in the task design that requires external resolution.Optimal Planning: The use of Topological Sort on the Condensation Graph provides a guaranteed, valid schedule. This is the optimal sequencing plan for the execution engine.Critical Time Prediction: The Longest Path calculation provides the most valuable output: the minimum time $T_{min}$ in which the entire project can be completed. Management should focus its efforts on reducing the duration of tasks that lie on this critical path.In conclusion, this assignment successfully implemented and analyzed three interconnected, linear-time graph algorithms, demonstrating their power in solving real-world scheduling and optimization challenges with high efficiency.
